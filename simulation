#rm(list=ls())
library(nleqslv)
datt=NULL
ppois=function(x,alpha,theta){
f=1-((1-alpha)/(1+theta)^(x+1)+alpha/(1+2*theta)^(x+1))
return(f)
}

r.pois <- function(n, L,T)
{
U <- runif(n)
X <- rep(0,n)
# loop through each uniform
for(i in 1:n)
{
# first check if you are in the first interval
if(U[i] < ppois(0,L,T))
{
X[i] <- 0
} else
{
# while loop to determine which subinterval,I, you are in
# terminated when B = TRUE
B = FALSE
I = 0
while(B == FALSE)
{
# the interval to check
int <- c( ppois(I, L,T), ppois(I+1,L,T) )
# see if the uniform is in that interval
if( (U[i] > int[1]) & (U[i] < int[2]) )
{
# if so, quit the while loop and store the value
X[i] <- I+1
B = TRUE
} else
{
# If not, continue the while loop and increase I by 1
I=I+1
}
}
}
}
return(X)
}

r.inarnpl=function (n, alpha, lambda,theta, n.start = NA) 
{
    length. <- n + n.start
    x <- rep(NA, times = length.)
    error <- r.pois(length., lambda,theta)
        x[1] <- error[1]
    for (t in (2):length.) {
        x[t] <- 0
        for (j in 1:1) {
            x[t] <- x[t] + rbinom(1, x[t - 1], alpha)
        }
        x[t] <- x[t] + error[t]
    }
    ts(x[(n.start + 1):length.], frequency = 1, start = 1)
}

pdfn=function(x,alpha,theta){

f=theta*((1-alpha)/(1+theta)^(x+1)+2*alpha/(1+2*theta)^(x+1))
return(f)

}

logl <- function(theta,data){
alpha=theta[1]
 lambda1=theta[2]
theta1=theta[3]
  length.=length(data) 
t=NULL
x=vector(length=length.)
x[1]=lambda1/(1-alpha)
  for (t in 2:length.) {
l=data[t-1]
k=data[t]
x[t]=0
    for (i in 0:min(k,l)) {
      x[t]=x[t]+dbinom(x=i,size=l,prob=alpha)*pdfn(k-i,lambda1,theta1)   }
}
f=x[2:length.]
return(f)
}


logl1=function(theta,data){-sum(log(logl(theta,data)))}

mlep=NULL
mlealpha=NULL
mletheta=NULL
ywalpha=NULL
ywtheta=NULL
ywp=NULL

biasp=NULL
biasalpha=NULL
biastheta=NULL

clsp=NULL
clsalpha=NULL
clstheta=NULL

msep=NULL
msealpha=NULL
msetheta=NULL

mrep=NULL
mrealpha=NULL
mretheta=NULL

p2=0.5
alpha2=0.5
theta2=2
nn=500

logllse=function(par){
p1=par[1]
alpha1=par[2]
theta1=par[3]

xt=datt[2:nn]
xt1=datt[1:(nn-2)]
f=sum((xt-p1*xt1-(2-alpha1)/(2*theta1))^2)

return(f)
}


for( j in 1:500)
{
datt=NULL
datmean=NULL
alpha=NULL
theta=NULL
my_acf=NULL
x1=NULL
ppp=NULL
datt=as.numeric(r.inarnpl(nn,p2,alpha2,theta2,200))

theta0=c(p2,alpha2,theta2)
my_acf = acf(datt,plot=F)
ppp=my_acf$acf[2]

qq=function(x){
alpha=2*(1-x*mean(datt)*(1-ppp))
ff=1+(4-alpha*(alpha+2))/(2*(2-alpha)*x*(1+ppp))-var(datt)/mean(datt)
return(ff)
}

x1=uniroot(qq,c(1,2),lower=1,upper=2,maxiter=10000)$root
alpha=2*(1-x1*mean(datt)*(1-ppp))

ywp[j]=ppp
ywalpha[j]=alpha
ywtheta[j]=x1

######################

theta01=c(ppp,alpha,x1)
resultlse=optim(par=theta0,fn=logllse,method="N",hessian=T)

clsp[j]=resultlse$par[1]
clsalpha[j]=resultlse$par[2]
clstheta[j]=resultlse$par[3]

####################

result=constrOptim(theta=theta0,f=logl1,data=datt,grad=NULL,ui=rbind(c(0,1,0),c(0,-1,0)),ci=c(0,-1))

mlep[j]=result$par[1]
mlealpha[j]=result$par[2]
mletheta[j]=result$par[3]

}

mlebiasp=mean((mlep-p2))
mlebiasalpha=mean((mlealpha-alpha2))
mlebiastheta=mean((mletheta-theta2))

ywbiasp=mean((ywp-p2))
ywbiasalpha=mean((ywalpha-alpha2))
ywbiastheta=mean((ywtheta-theta2))


clsbiasp=mean((clsp-p2))
clsbiasalpha=mean((clsalpha-alpha2))
clsbiastheta=mean((clstheta-theta2))


mlemsep=sum((mlep-p2)^2)/500
mlemsealpha=sum((mlealpha-alpha2)^2)/500
mlemsetheta=sum((mletheta-theta2)^2)/500

ywmsep=sum((ywp-p2)^2)/500
ywmsealpha=sum((ywalpha-alpha2)^2)/500
ywmsetheta=sum((ywtheta-theta2)^2)/500

clsmsep=sum((clsp-p2)^2)/500
clsmsealpha=sum((clsalpha-alpha2)^2)/500
clsmsetheta=sum((clstheta-theta2)^2)/500


mlemrep=sum(((mlep/p2)))/500
mlemrealpha=sum(((mlealpha/alpha2)))/500
mlemretheta=sum(((mletheta/theta2)))/500

ywmrep=sum(((ywp/p2)))/500
ywmrealpha=sum(((ywalpha/alpha2)))/500
ywmretheta=sum(((ywtheta/theta2)))/500

clsmrep=sum(((clsp/p2)))/500
clsmrealpha=sum(((clsalpha/alpha2)))/500
clsmretheta=sum(((clstheta/theta2)))/500

