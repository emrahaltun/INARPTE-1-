library(nleqslv)
datt=NULL
ppois=function(x,alpha,theta){
f=1-((1-alpha)/(1+theta)^(x+1)+alpha/(1+2*theta)^(x+1))
return(f)
}

r.pois <- function(n, L,T)
{
U <- runif(n)
X <- rep(0,n)
# loop through each uniform
for(i in 1:n)
{
# first check if you are in the first interval
if(U[i] < ppois(0,L,T))
{
X[i] <- 0
} else
{
# while loop to determine which subinterval,I, you are in
# terminated when B = TRUE
B = FALSE
I = 0
while(B == FALSE)
{
# the interval to check
int <- c( ppois(I, L,T), ppois(I+1,L,T) )
# see if the uniform is in that interval
if( (U[i] > int[1]) & (U[i] < int[2]) )
{
# if so, quit the while loop and store the value
X[i] <- I+1
B = TRUE
} else
{
# If not, continue the while loop and increase I by 1
I=I+1
}
}
}
}
return(X)
}

r.inarnpl=function (n, alpha, lambda,theta, n.start = NA) 
{
    length. <- n + n.start
    x <- rep(NA, times = length.)
    error <- r.pois(length., lambda,theta)
        x[1] <- error[1]
    for (t in (2):length.) {
        x[t] <- 0
        for (j in 1:1) {
            x[t] <- x[t] + rbinom(1, x[t - 1], alpha)
        }
        x[t] <- x[t] + error[t]
    }
    ts(x[(n.start + 1):length.], frequency = 1, start = 1)
}

pdfn=function(x,alpha,theta){

f=theta*((1-alpha)/(1+theta)^(x+1)+2*alpha/(1+2*theta)^(x+1))
return(f)

}

logl <- function(theta,data){
alpha=theta[1]
 lambda1=theta[2]
theta1=theta[3]
  length.=length(data) 
t=NULL
x=vector(length=length.)
x[1]=lambda1/(1-alpha)
  for (t in 2:length.) {
l=data[t-1]
k=data[t]
x[t]=0
    for (i in 0:min(k,l)) {
      x[t]=x[t]+dbinom(x=i,size=l,prob=alpha)*pdfn(k-i,lambda1,theta1)   }
}
f=x[2:length.]
return(f)
}


logl1=function(theta,data){-sum(log(logl(theta,data)))}

mlep=NULL
mlealpha=NULL
mletheta=NULL
ywalpha=NULL
ywtheta=NULL
ywp=NULL

biasp=NULL
biasalpha=NULL
biastheta=NULL

msep=NULL
msealpha=NULL
msetheta=NULL

mrep=NULL
mrealpha=NULL
mretheta=NULL

p2=0.7
alpha2=0.7
theta2=0.5
nn=100


for( j in 1:1000)
{
datt=NULL
datmean=NULL
alpha=NULL
theta=NULL
my_acf=NULL
x1=NULL
ppp=NULL
datt=r.inarnpl(nn,p2,alpha2,theta2,200)

theta0=c(p2,alpha2,theta2)
my_acf = acf(datt,plot=F)
ppp=my_acf$acf[2]

qq=function(x){
theta=(2-x)/(2*mean(datt)*(1-ppp))
ff=((x*(x + 2) + 2*theta*(x - 2) - 4)/(4*theta^2) + (ppp*(x - 2))/(2*theta))/(ppp^2 - 1)-var(datt)
return(ff)
}

x1=uniroot(qq,c(0,1),lower=0,upper=1,maxiter=10000)$root
theta=(2-x1)/(2*mean(datt)*(1-ppp))

ywp[j]=ppp
ywalpha[j]=x1
ywtheta[j]=theta

result=constrOptim(theta=theta0,f=logl1,data=datt,grad=NULL,ui=rbind(c(0,1,0),c(0,-1,0)),ci=c(0,-1))

mlep[j]=result$par[1]
mlealpha[j]=result$par[2]
mletheta[j]=result$par[3]

}

mlebiasp=mean((mlep-p2))
mlebiasalpha=mean((mlealpha-alpha2))
mlebiastheta=mean((mletheta-theta2))

ywbiasp=mean((ywp-p2))
ywbiasalpha=mean((ywalpha-alpha2))
ywbiastheta=mean((ywtheta-theta2))


mlemsep=sum((mlep-p2)^2)/1000
mlemsealpha=sum((mlealpha-alpha2)^2)/1000
mlemsetheta=sum((mletheta-theta2)^2)/1000

ywmsep=sum((ywp-p2)^2)/1000
ywmsealpha=sum((ywalpha-alpha2)^2)/1000
ywmsetheta=sum((ywtheta-theta2)^2)/1000

mlemrep=sum(((mlep/p2)))/1000
mlemrealpha=sum(((mlealpha/alpha2)))/1000
mlemretheta=sum(((mletheta/theta2)))/1000

ywmrep=sum(((ywp/p2)))/1000
ywmrealpha=sum(((ywalpha/alpha2)))/1000
ywmretheta=sum(((ywtheta/theta2)))/1000

